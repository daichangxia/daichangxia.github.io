<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm之内存模型]]></title>
    <url>%2F2019%2F03%2F17%2Fjvm%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[屏幕剪辑的捕获时间: 2019/3/16 10:56 注: 线程共享数据区:虚拟机栈,本地方法栈,程序计数器. 线程隔离数据区:方法区,堆,执行引擎,本地库接口. 简介:由于java将内存的管理交给了虚拟机,了解内存结构,有利于排查内存溢出和泄露问题. jvm运行时的数据区域:程序计数器:\1. 一块很小的内存区域,主要作用是当前线程所执行字节码的行号指示器.字节码解释工作是,根据改变程序计数器的值来选取下一条所执行的字节码指令.例如:分支,循环,跳转,异常处理.因为jvm多线程是通过线程轮流切换来实现的,因此程序计数器是线程私有的. \2. 如果是正在执行java方法,此区域存储的是正在执行的虚拟机的字节码指令.如果是native方法,此区域为undefined.程序计数器是唯一一片不会出现outofmemoryerror的区域. java虚拟机栈\1. 描述的是方法的执行的内存模型,每一个方法的执行都会创建一个栈桢,用于存储局部变量表,操作数栈,动态链接,方法出口信息. \2. 局部变量表就是平常所说的栈,存储着编译期可知的基本数据类型,对象引用,returnAddress类型.基本单位是32个字节的slot,所需的空间在编译期就可以确定.常出现的异常:stackOverFlowError:请求的栈深度大于所允许的深度.OutMemoryError:虚拟机栈允许动态扩展的情况下,无法申请到足够的内存. 本地方法栈和虚拟机栈的区别是: 虚拟机栈是为java方法提供服务,而本地方法栈则是为了native方法提供服务. java堆(重点)\1. 是java虚拟机所管理的最大的一块内存区域.被所有线程共享.唯一目的是存放对象的实例.按照java虚拟机规范:堆中存放着所有的对象实例和数组信息.后续技术更加成熟也有稍微变化的地方. \2. java堆是垃圾收集器管理的主要区域.因此称为GC堆.按照内存回收方面看,可以分为新生代和老年代.永久代在哪?看下面的方法区.0.0 \3. java堆可以存放在不连续的内存空间,只要是逻辑上连续即可.当无法分配更多的实例时,会抛出OutOfMemoryError. 方法区\1. 主要是存放被虚拟机加载的类的信息,常量,静态变量,编译后的代码. \2. HotSpot虚拟机的设计团队选择了将GC分代管理扩展到了方法区,因此方法区就成了GC分代所说的永久代.这个区域很少有垃圾回收行为存在,但是也需要常量的回收和类型的卸载.不过次区域的回收,依旧是难点. 运行时的常量池\1. 运行期的常量池是方法区的一部分,用于存放编译期生成的字面量和符号引用. \2. 需要注意的是和局部变量表的局别.同样是存储编译期的数据,不过一个是方法的参数,方法内定义的变量.另一个是存储字面量的常量. 直接内存直接内存不是jvm的内存.是介于本地方法栈中的native方法,与java堆之间的一种机器中的内存.主要是在native方法进行io流的时候进行缓存数据的区域. 对象的访问在了解了虚拟机运行时候的数据区域后,下面来看下是如何进行对象访问的. 例如: Object obj = new Object(); 假设这块方法出现在方法体中,其中Object obj会映射到虚拟机栈的栈桢的局部变量表中的reference类型. new Object()则会映射到java堆中.另外java堆中还必须能够查到次对象类型的数据(对象的类型,父类,实现的接口,方法),这些数据存放在方法区.其中reference方法是如何定位到java堆中的?主要有2种方式: \1. 句柄池访问: 屏幕剪辑的捕获时间: 2019/3/16 12:38 在java堆中划分出一块内存作为句柄池,reference存储的是句柄池的地址.句柄池内存储着对象实例的数据和对象类型的数据. 主要优点是:对象进行移动时,只需要改变句柄池中的对象实例信息. \2. 直接指针访问方式 屏幕剪辑的捕获时间: 2019/3/16 12:41 reference存储的是对象实例的数据,这是就要考虑如何放置对象类型的数据的地址.主要优点是节省了一次指针的定位,速度更快.sun 的hotspot所用的虚拟机主要是采用此方案. OOM异常java堆溢出通过-Xms指定最小值,-Xmx指定最大值 提示是java heap space,查看对象信息,确定是否是要用的,如果对象必须要或者,则是内存溢出,此时加大虚拟机内存.如果对象不必须活着,则是内心泄露,此时定位到对象点,进行处理. 虚拟机栈和本地方法栈溢出通过-Xss128k,表示指定大小为128k,主要有2种异常 \1. 线程请求的深度大于虚拟机允许的最大深度:Stack OverflowError. \2. 虚拟机在扩展栈时,无法请求到足够的内存:OOM 运行时常量池溢出方法区内存,指定大小和方法区一致.提示信息是:PermGen space . 方法区溢出通过-XX:PerSize和-XX:MaxPermSize指定大小,提示信息是:PermGen space ,方法区主要存储的是Class的信息,如类名,修饰符,常量池,字段描述,方法描述等. 本机直接内存溢出通过-XX:MaxDirectMemorySize指定大小,仅是抛出OOM溢出.]]></content>
      <categories>
        <category>jvm</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>java内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm之字节码执行引擎]]></title>
    <url>%2F2019%2F03%2F04%2Fjvm%E4%B9%8B%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[概述从宏观上来说,java虚拟机的执行引擎基本上都是按照输入字节码,字节码解析,输出执行结果.从概念模型上来说,分为方法的调用和字节码的执行.下面详细描述: 运行时的栈桢结构2.1 简介栈桢是支持方法调用和字节码执行的数据结构.他是虚拟机运行时数据区的虚拟机栈的栈元素.栈桢存储着局部变量表,操作数栈,动态连接和方法返回地址等信息.每一个方法的调用到完成都对应着虚拟机栈的入栈到出栈的过程.在代码编译的时候,栈桢的深度就已经确定了,因此一个栈需要多少内存,不会受到运行期数据的影响. 在活动线程中,只有最顶层的当前栈桢是有效的.引擎中所有的字节码指令都是针对当前栈桢的. 2.2 局部变量表一组变量值存储空间.用于存放方法的参数和方法内部定义的变量.最小单位是slot.一个slot可以存放32位的数据类型,比如:short,byte,boolean,char,float,int,refearce(对象实例的引用).而对于64位的long和double,则会使用2个连续的slot来存储. 注意:java中的long和double都是非原子性的,在32位操作系统上,即读写都是分离的.每次读32位数据.因此在高并发性,需要volatile关键字标注. 但是在局部变量表里面,局部变量表是建立在线程的栈桢上,单线程私有,因此不会要安全问题. slot顺序: 虚拟机通过索引使用局部变量表.方法在执行时,第0位索引是当前实例变量的引用,即this关键字.其余则会按照顺序排序. 为节省栈桢空间,slot是可以重复使用的.即一个变量即使后续确定不再使用,则也不会立即回收其空间. 对一个变量赋值null使其被回收是没有意义的,因此在经过JIT编译器后,赋值null的操作会被清除掉. 局部变量表没有在类加载准备阶段对变量赋值,因此如果不赋值,会在编译期间报错. 2.3 操作数栈操作栈是一个先入后出的栈.可存储任意类型的数据.32位的栈容量为1,64位的为2.操作栈的深度不会超过max_stacks的值.在方法执行的时候,操作栈是空的,随着方法的执行,不断进行入栈和出栈操作. 例子:int a +int b ,在执行时a和b在栈顶的2个位置,然后字节码指令iadd,栈顶2个元素出栈,则会对其相加,然后将结果入栈. 在概念模型中,两个栈是独立的,但是虚拟机做了一些处理,2个栈可能会共享一部分数据.以便在调用方法时,无需再进行参数的复制传递.称之为:基于栈的执行引擎. 2.4 动态连接 每个栈桢都包含一个指向运行期常量池中该栈桢所属方法的引用.这个引用是为了动态连接. 2.5 方法返回地址 方法开始执行后,会有2条退出指令. ① 正常退出:遇到方法返回的字节码指令.栈桢中存储了PC计数器的值,作为返回地址 ② 异常退出: athrow 字节码指令.通过异常处理器表来确定返回地址. 方法调用方法调用不是方法执行,方法调用唯一的任务是确定调用那个方法.因为在编译阶段,没有连接过程,只是进行了符号引用,而没有真正分配内存布局的入口地址(直接引用).这个特性给java带来了强大的动态加载能力,只有在类加载期间,甚至是执行期间才能确定目标方法的直接引用. 3.1 解析:在解析阶段,会有一部分符号引用变为直接引用: 包括:静态方法,私有方法,实例构造器,父类方法4中.再加上final修饰的方法 3.2 分派① 静态分派:依靠静态类型来执行方法执行版本的分配动作.典型的应用是方法的重载,会自动加载适合的版本. ② 动态分派:典型额应用是方法的重写.即在运行期才会确定方法执行的版本.]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>字节码执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm类加载机制]]></title>
    <url>%2F2019%2F03%2F04%2Fjvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.概述得知class文件是一段规则有序的二进制流后,类加载流程简述是: 虚拟机将二进制流加载到内存,对数据进行校验,转换解析和初始化,最后形成可以直接被虚拟机使用的java类型. 需要注意的是,java的类型的加载,连接,初始化都是在运行期执行的,从而提供了动态扩展的特性. 由于动态加载的特性,其中解析动作不一定在初始化之前执行. 2.类加载过程2.1 加载① 通过一个类的权限定名称获取这个类的二进制字节流 ② 将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构 ③ 在内存中生成一个java.lang.class对象,作为方法区这个类的各种数据的访问接口 注: 在类创建的时候,并不包括数组,数组是由java虚拟机直接创建的,不经过类加载器. 但是数组中的元素类型,则会通过类加载器创建. 2.2 验证验证主要是保证字节流中的信息不回危害虚拟机本身,并且符合虚拟机的规范要求.主要有4个方面的验证: ① 文件格式验证: 对开头的二进制魔数进行验证,对主版本号的验证,等等. 目的是保证二进制能够正确解析,存到方法区之内. ② 元数据验证:是否符合java语言规范,比如继承了一个被final修饰的类. ③ 字节码验证: 通过分析数据流和控制流,确定语义是否合法并且符合逻辑. ④ 符号引用验证: 可以看做是对类自身外的信息进行的匹配性校验,比如:是否可以通过权限定名找到相应的类,或者符号引用中的方法字段的可访问性,是否为public或者private等. 2.3 准备此阶段是为类变量分配内存并设置初始值的阶段.这里分配的内存都在方法区进行.并且只会实例化static修饰的变量.类实例变量会在进行类初始化的时候,分配在堆内存中.需要注意的是,private static int a=1;在这句代码中设置的初始值为0,并不是1, ①在类进行初始化后,会为1. ② private static final int a=1,这时也是1. 下面是基本数据类型的零值(准备阶段初始值): 2.4 解析将符号引用变换为直接引用. ① 符号引用: 和内存无关,一组用来描述所引用目标的一组符号. ② 直接引用: 和内存有关,直接引用的数据,在内存中肯定存在.可以是指针,偏移量或者句柄. 主要解析的符号引用为: （1） 类或者接口 （2） 字段 （3） 类方法 （4） 接口方法 （5） 方法类型 （6） 方法句柄 （7） 调用点限定符 2.5 初始化根据java类中的代码进行初始化.也可以说是执行类构造器()方法的执行过程. 类构造器()的具体流程是: （1） 由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生. （2） 和类构造函数不同,不会去调用父类构造器,因为虚拟机会保证父类构造器在子类之前,肯定会执行完.因此第一个执行的类构造器是java.lang.Object. （3） 如果一个类中没有静态语句块和变量赋值操作,则不会生成类构造器. （4） 接口中的如果没有用到父类的变量,则不会生成父类构造器. （5） 虚拟机会保证类构造器在多线程环境下的加锁与同步. 3.类加载器3.1 概述通过一个类的全限定名称来获取类的二进制流的动作 3.2 类与类加载器一个类的唯一性是由同一个类加载器和和这个类本身共同决定的. 一个简单的类加载器: 用这个类加载器和系统加载出来的类,不是同一个类. 3.3 双亲委派模型对于java开发人员来说,有3种系统提供的类加载器: （1） 启动类加载器(bootstrap classLoder):加载/lib下的类,不能被java程序直接引用 （2） 扩展类加载器(extension_classLoder): 由sun.misc.Launcher$ExtClassLoder实现,加载/lib/ext下的类,java程序可以直接使用 （3） 应用程序类加载器(Application classLoder): 由sun.misc.Launcher$app-ClassLoder实现,加载用户类路径下的类.可以直接使用,并且默认类加载器为这个 类加载器层次的关系可以用双亲委派模型来说明,不过层级间不是父子继承关系,而是组合关系.当然这个关系模型是java设计者所推荐的模型. 双亲委派工作流程是: 当一个类加载器接收到加载类的请求时,不会立马去加载这个类,而是将这个请求委派给父类,一直到启动类加载器.当父类无法搜索到这个类时,最终类加载器才会去加载. 3.4 双亲委派模型的破坏1) 在这个模型出现之前,可以继承java.lang.ClassLoder,重写loadClass(),后续建议只有在loadClass()加载失败后,然后再去加载自己的类. 2) 线程上下文类加载器的出现.线程还没创建时,他是父类加载器,如果全局没有设置,则会默认为应用加载器.从而实现了父类加载器请求子类去加载类.所有的SPI操作都是这个原理,比如常见的jdbc,jndi 3) 热部署话等动态的追求,OSGN的java模块化标准.使得每一个模块都有独自的类加载器.双亲委派模型成为一个网状结构,收到类加载请求时,按照以下的标准执行:]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类加载机制</tag>
        <tag>双亲委派模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm之字节码]]></title>
    <url>%2F2019%2F03%2F04%2Fjvm%E4%B9%8B%E5%AD%97%E8%8A%82%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1.1 机器码与字节码①机器码(Native code): 可由CPU直接读取操作的机器指令.处于最底层,不需要编译.速度最快.不可跨平台.依靠硬件存在. ②字节码:是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。依靠平台存在. 以前用机器码操作系统，现在是用字节码操作机器码，进一步操作系统,使得语言跨平台成为可能. 1.2.跨平台原理:java语言一如既往的保持着”一次编写,到处运行的特性”,依靠的就是其JVM.JVM不关注语言的来源,只关注的是”CLASS 二进制文件”,只要符合JVM的类的编写规范,就可以经过JVM进行字节码到机器码的转换. 因此, 功能性比较: java或者其他语言&gt;字节码&gt;机器码 速度上:相反 1.3.class文件结构简介:1.3.1.class内容格式Class文件是一组以8位字节为单位的二进制流,各个数据项目以严格的顺序紧凑的排列在CLass文件中,中间没有分隔符.因此文件中的数据全是必要的数据.当遇到需要占用8个字节以上的数据时,则会按照高位在前的方式分割为若干个8位字节进行存储. ①.高位在前,高位字节在地址最低位 例如:32位下,int i=10 低位在前为: 00001010 00000000 00000000 00000000 而在高位优先的内存中： 00000000 00000000 00000000 00001010 字节码本身是无序的,需要有一定的规则去读取数据,高位优先更符合人的操作习惯,但是在X86处理器采用的是低位优先的规则. 1.3.2.class 结构CLass文件中定义了类似于C语言的2种数据类型:无符号数和表. ①.无符号数是最基本的数据类型,用u1,u2,u4,u8分别表示1,2,3,8个字节. ②.表是由无符号数和表构成的复合数据类型.习惯性的以”_info”结尾. 因此Class文件本质上是由众多无符号数组成的一张表. 下面贴上一张结构组成图: 因此,一个class里面会有1个4个字节的magic+1个2个字节的minor_version……..组成.其中具体含义后续详细介绍. 1.3.2.1 magic 魔数在对一个文件进行类型判断时,比如是.png还是.jpg,文件存储标准中都会使用魔数来进行判断.同样,判断是否为一个class文件,也使用了这个标准.对于class文件,开头的前4个字节为魔数,值为:0XCAFEBABE,用来表示这是一个class文件.紧接着魔数后面的4个字节存储着class文件的版本号,5,6位次版本号,7,8是主版本号.高版本的JDK会向下兼容以前版本的class文件,但是会拒绝执行超过其版本的class文件,即使文件格式没有发生变化. 对一个class文件,用16进制编辑器打开,可以看到上面的结果. 第一行的0xCAFEBEBE为文件类型标志,5,6为0x0000次版本号,7,8为0x0032,十进制为50,表示可被1.6以上的jdk进行编译.下面是jdk和class文件版本对应表: 1.3.2.2 constant_pool (常量池)紧接着主版本号之后,便是常量池的入口,可以把常量池比作class文件的资源仓库.这是文件中第一个表数据结构,由于常量的个数不固定,所以在常量池前面会有一个u2类型的数据,constant_pool_count来表示类中定义的常量池的个数.不过常量池会将索引为0的位置留作备用,用来满足指向常量池的索引值需要表示为”不引用任何常量池”的意思.因此常量池的实际个数为constant_pool_count-1. 常量池主要有2中结构:字面量和符号引用. ①.字面量:java语言层面的常量,如文本字符串,final声明的常量等. ②.符号引用:编译方面的概念,主要有类和接口的全限定名,字段的名称和描述符,方法的名称和描述符. 在C/C++,会经历编辑,编译,链接,运行阶段,但是java中没有链接这一阶段,而是采用的是在虚拟机加载类文件的时候动态连接.意思是class文件中不会保存方法字段的占用内存信息,只有在运行期间进行转换才会得到.这部分内容在类加载机制中会详细说明. 常量池中每一个常量都是一张表,开始的第一位是u1类型的标志位,对应关系如下: 每个常量又都会有各自的结构组成, 具体class字节码分析工具,可以用jdk下的bin目录下,javap工具,通过执行: javap -verbose ttclass ​ 可将class转化为字节码,输出. 1.3.2.3 访问标志主要是用于标志一些类和接口层次的信息,占用2个字节 例如:一个普通的public类,access_flags的值为:0x0001+0x0020=0x0021 1.3.2.4 类索引,父类索引,接口索引访问标志后面是这些索引的信息,其中类索引和父类索引是一个u2类型的数据,接口索引是一组u2类型的数据. 顺序为:类索引+父类索引+接口索引大小+接口索引 1.3.2.5 字段表集合字段表是用于描述类或者接口中声明的变量.字段主要有类级变量和实例级变量,不包括方法内部声明的变量. 其中access_flag和类中的访问标志相似.可以设置的值如下: 然后name_index和descriptor_index分别代表了简单名称和描述符; 概念: ① 全限定名:类名中的点变成”/“,例如:org/da/dad/aa.class ② 简单名称: 没有类型和参数修饰的字段或者方法,inf()简称为inf ③ 描述符: 描述字段的数据类型.基本数据类型通常用一个大写字母表示,对象类型用”L+全限定名”来表示. 对于数组类型,一维数组使用[描述,例如int[],用’[I’表示.二维的用’[[‘表示,例如:Integer[][]用[[I表示. 后续的attribute_count和attribute只有在给字段添加默认值的时候,才会显示. 1.3.2.6 方法表集合字段表后面跟着的是方法表,两者很类似, 其中的访问标志选项为: 顺序为:方法数量+访问标志+…(结构体) 其中,方法里面的代码在编译成字节码后,会存放在方法属性表里面,对应的key为Code. 1.3.2.7 属性表集合和其他结构不同,属性表不要求有严格的顺序,长度和内容.只需要和已有的属性名不同即可. java虚拟机定义了21个预定义属性,详情可看书中,暂不一一列举. 对于每一个属性,都会用一个constant_utf8_info属性来表示. 其中简要说下Code属性: code属性是方法里面的代码编译后的字节码: ① attribute_name_index : constant_utf8_info的常量,固定值为”code”,表示属性名称. ② attribute_length: 属性长度,为6个字节. ③ max_stack: 操作栈的深度.java虚拟机会根据这个深度来分配. ④ max_locals: 局部变量表所需要的空间. ⑤ code_length ,code: java源文件编译后的字节码指令. 1.4 字节码指令java虚拟机的指令是由一个字节的,代表某种操作含义的数字(操作码)+(0,n)个代表此操作所需的参数(操作数)组成.但是由于java虚拟机的架构是面向操作数栈而不是面向寄存器的,因此一般都是只有一个操作码组成. 一个字节的操作码长度为:0-255. 因此java虚拟机的执行基础模型为: 1.4.1 字节码与数据类型 在java虚拟机指令集中,大多都会携带其操作所需的数据类型,但是并非所有的数据类型都会有对于的指令.会有一些单独的指令在必要的时候,将不支持的类型转化为支持的.大体上可划分为9个指令. 1.4.2 加载和存储指令主要将数据在栈帧中的局部变量表和操作数栈之间传输,主要包括: ① 将一个局部变量加载到操作栈:iload等; ② 将一个数值从操作栈存储到局部变量表: istore等 ③ 将一个常量加载到操作栈:bipush 1.4.3 运算指令用于对操作数栈上的数值进行某种运算,然后把结果存到栈顶. 注意:java虚拟机没有操作byte,boolean,short,char的指令,最后都会转化为int指令来特殊操作. 1.4.4 类型转化指令 java数据类型及其大小,在进行转化的时候,是默认支持小范围向大范围转化的.而在大范围向小范围转化时,需要进行强制转化. 1.4.5 对象的创建以及访问指令数组和类实例用到了不同的创建指令. 1.4.6 操作数栈管理指令和操作普通的堆栈一样,java虚拟机提供了用于直接操作操作数栈的指令: ① 出栈: pop,pop2 ② 复制栈顶数值,并重新压入栈顶,dup,dup2 ③ 将栈最顶端的2个值互换,swap 1.4.7 控制转移指令有条件或者无条件的修改寄存器的值: 1.4.8 方法调用和返回指令 1.4.9 异常处理指令显示抛出异常的语句,是由athrow指令实现,并且除了显示跑出异常,java虚拟机也会有一些指令进行异常检测. 处理异常(catch语句),没有字节码指令,这部分功能是由异常表来完成 1.4.10 同步指令包括2种同步方式,都是由管程(Monitor)支持: ① 方法级同步: 不通过字节码来操作,是在方法的调用和返回中实现. 流程是:从常量池中取出acc_synchronized得知是否为同步方法,如果是,当前线程则会持有管程,方法执行完后,释放管程.同一个管程只能在一个线程中存在. ② 同步一段指令集序列: 是由java语言的synchronized语句块表示,这个关键字由2个指令支持:monitorenter和monitorexit 例如: 以下代码的字节码为:]]></content>
      <categories>
        <category>jvm</category>
        <category>类文件结构</category>
      </categories>
      <tags>
        <tag>字节码</tag>
        <tag>字节码指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java之线程,线程池]]></title>
    <url>%2F2019%2F03%2F03%2Fjava%E4%B9%8B%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[1.线程与进程&nbsp;&nbsp; 进程是系统进行资源分配和调度的独立单位,一个进程下可以包括多个线程.一个进程在执行时,总需要多个子任务去执行,这就需要多线程.最大的利用CPU的空闲时间去执行更多的任务. 2 .创建线程2.1继承Thread类12345678910111213public class StringUtil extends Thread&#123; @Override public void run() &#123; System.out.println(this.getName()); super.run(); &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;100;i++) &#123; new StringUtil().start(); &#125; &#125; &#125; 2.2 实现runnable接口123456789101112public class Aa implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; for(int i=0;i&lt;100;i++) &#123; new Thread(new Aa()).start(); &#125; &#125;&#125; 2.3 两种方法对比 看源码1234567891011121314151617publicclass Thread implements Runnable &#123; /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */ private static native void registerNatives(); static &#123; registerNatives(); &#125; private volatile String name; private int priority; /* Whether or not the thread is a daemon thread. */ private boolean daemon = false; /* Fields reserved for exclusive use by the JVM */ private boolean stillborn = false; private long eetop; 在Thread源码中,Thread是Runnable的实现.因此可以得出, a) 我们如果使用继承Thread类,系统已经给我们经过继承,封装好了.可以直接使用. b) 我们如果直接使用实现Runnable接口方式,需要将我们的类放进Thread方法中,去生成一个Thread类,从而具有Thread的所有功能. 由于两种方法基本上是一样的,但是java是单继承的,为了不会影响到我们写的类去继承其他类,所以推荐使用第二种方法. 从demo可知,run()方法是线程中我们需要实现的业务.start()方法是开启一个线程. start()方法源码:1234567891011121314151617181920212223242526272829303132public synchronized void start() &#123; /** * This method is not invoked for the main method thread or &quot;system&quot; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state &quot;NEW&quot;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group&apos;s list of threads * and the group&apos;s unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; //开启线程 start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; &nbsp;&nbsp;可知真正开启一个线程的方法是start0(),并且在创建的时候,用synchronized关键字,进行锁住;同时,可知为了进行线程的管理,将创建的线程加入了线程组. Thread类 线程的方法（Method）、属性（Property） 1）优先级（priority） &amp;nbsp;&amp;nbsp;每个类都有自己的优先级，一般property用1-10的整数表示，默认优先级是5，优先级最高是10；优先级高的线程并不一定比优先级低的线程执行的机会高，只是执行的机率高；默认一个线程的优先级和创建他的线程优先级相同； 2）Thread.sleep()/sleep(long millis) &amp;nbsp;&amp;nbsp;当前线程睡眠/millis的时间（millis指定睡眠时间是其最小的不执行时间，因为sleep(millis)休眠到达后，无法保证会被JVM立即调度）；sleep()是一个静态方法(static method) ，所以他不会停止其他的线程也处于休眠状态；线程sleep()时不会失去拥有的对象锁。 作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的时间给其他线程执行的机会； 3）Thread.yield() &amp;nbsp;&amp;nbsp; 让出CPU的使用权，给其他线程执行机会、让同等优先权的线程运行（但并不保证当前线程会被JVM再次调度、使该线程重新进入Running状态），如果没有同等优先权的线程，那么yield()方法将不会起作用。 4）thread.join() 使用该方法的线程会在此之间执行完毕后再往下继续执行。 5）object.wait() 当一个线程执行到wait()方法时，他就进入到一个和该对象相关的等待池(Waiting Pool)中，同时失去了对象的机锁—暂时的，wait后还要返还对象锁。当前线程必须拥有当前对象的锁，如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常,所以wait()必须在synchronized block中调用。 6）object.notify()/notifyAll() 唤醒在当前对象等待池中等待的第一个线程/所有线程。notify()/notifyAll()也必须拥有相同对象 锁，否则也会抛出IllegalMonitorStateException异常。 7）Synchronizing Block Synchronized Block/方法控制对类成员变量的访问；Java中的每一个对象都有唯一的一个内置的锁，每个Synchronized Block/方法只有持有调用该方法被锁定对象的锁才可以访问，否则所属线程阻塞；机锁具有独占性、一旦被一个Thread持有，其他的Thread就不能再拥有（不能访问其他同步方法），方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。 注: 线程组是一个进程下所有的线程管理类,线程以树形的结构存储 线程池是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销 继续查看:源码: 1private native void start0(); 可知最终是调用的原生C/C++方法去开启的一个线程. 3. 线程池: ThreadPoolExecutor&nbsp;&nbsp;ThreadPoolExecutor是jdk1.5之后package java.util.concurrent;官方提供的线程池创建类.主要负责线程的调度,任务的执行,线程池的管理等. 构造方法: 12345678 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 参数 说明 corePoolSize 核心线程池大小 maximumPoolSize 最大线程池大小 keepAliveTime 线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程有效时间 unit keepAliveTime时间单位 workQueue 阻塞任务队列 threadFactory 线程工厂 handler 当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理 重点讲解：其中比较容易让人误解的是：corePoolSize，maximumPoolSize，workQueue之间关系。 当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务 当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 线程池图解: 屏幕剪辑的捕获时间: 2019/2/26 22:23 其中,官方给出了工具类Executors,package java.util.concurrent;,用来快速创建一些线程池方案. 构造一个固定线程数目的线程池，配置的corePoolSize与maximumPoolSize大小相同，同时使用了一个无界LinkedBlockingQueue存放阻塞任务，因此多余的任务将存在再阻塞队列，不会由 RejectedExecutionHandler处理 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 构造一个缓冲功能的线程池，配置corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s,以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的 线程执行；线程空闲超过60s将会销毁 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 构造一个只支持一个线程的线程池，配置corePoolSize=maximumPoolSize=1，无界阻塞队列 LinkedBlockingQueue；保证任务由一个线程串行执行 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 构造有定时功能的线程池，配置corePoolSize，无界延迟阻塞队列DelayedWorkQueue；有意思的是： maximumPoolSize=Integer.MAX_VALUE，由于DelayedWorkQueue是无界队列，所以这个值是没有意义的 123456789101112public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); &#125;public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS, new DelayedWorkQueue(), threadFactory); &#125; 注: 工具类中提供的创建线程池,所用的队列都是无界队列,因此会存在OOM问题,当然,也可以自定制自己的线程池方案,自定义拒绝策略:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.RejectedExecutionHandler;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger; public class CustomThreadPoolExecutor &#123; private ThreadPoolExecutor pool = null; /** * 线程池初始化方法 * * corePoolSize 核心线程池大小----10 * maximumPoolSize 最大线程池大小----30 * keepAliveTime 线程池中超过corePoolSize数目的空闲线程最大存活时间----30+单位TimeUnit * TimeUnit keepAliveTime时间单位----TimeUnit.MINUTES * workQueue 阻塞队列----new ArrayBlockingQueue&lt;Runnable&gt;(10)====10容量的阻塞队列 * threadFactory 新建线程工厂----new CustomThreadFactory()====定制的线程工厂 * rejectedExecutionHandler 当提交任务数超过maxmumPoolSize+workQueue之和时, * 即当提交第41个任务时(前面线程都没有执行完,此测试方法中用sleep(100)), * 任务会交给RejectedExecutionHandler来处理 */ public void init() &#123; pool = new ThreadPoolExecutor( 10, 30, 30, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;Runnable&gt;(10), new CustomThreadFactory(), new CustomRejectedExecutionHandler()); &#125; public void destory() &#123; if(pool != null) &#123; pool.shutdownNow(); &#125; &#125; public ExecutorService getCustomThreadPoolExecutor() &#123; return this.pool; &#125; private class CustomThreadFactory implements ThreadFactory &#123; private AtomicInteger count = new AtomicInteger(0); @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); String threadName = CustomThreadPoolExecutor.class.getSimpleName() + count.addAndGet(1); System.out.println(threadName); t.setName(threadName); return t; &#125; &#125; private class CustomRejectedExecutionHandler implements RejectedExecutionHandler &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; // 记录异常 // 报警处理等 System.out.println(&quot;error.............&quot;); &#125; &#125; // 测试构造的线程池 public static void main(String[] args) &#123; CustomThreadPoolExecutor exec = new CustomThreadPoolExecutor(); // 1.初始化 exec.init(); ExecutorService pool = exec.getCustomThreadPoolExecutor(); for(int i=1; i&lt;100; i++) &#123; System.out.println(&quot;提交第&quot; + i + &quot;个任务!&quot;); pool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;running=====&quot;); &#125; &#125;); &#125; // 2.销毁----此处不能销毁,因为任务没有提交执行完,如果销毁线程池,任务也就无法执行了 // exec.destory(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;方法中建立一个核心线程数为30个，缓冲队列有10个的线程池。每个线程任务，执行时会先睡眠3秒，保证提交10任务时，线程数目被占用完，再提交30任务时，阻塞队列被占用完，，这样提交第41个任务是，会交给CustomRejectedExecutionHandler 异常处理类来处理。&nbsp;提交任务的代码如下：123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn&apos;t, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; 注意：41以后提交的任务就不能正常处理了，因为，execute中提交到任务队列是用的offer方法，如上面代码，这个方法是非阻塞的，所以就会交给CustomRejectedExecutionHandler 来处理，所以对于大数据量的任务来说，这种线程池，如果不设置队列长度会OOM，设置队列长度，会有任务得不到处理，接下来我们构建一个阻塞的自定义线程池 定制属于自己的阻塞线程池 : package com.tongbanjie.trade.test.commons; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ExecutorService; import java.util.concurrent.RejectedExecutionHandler; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; public class CustomThreadPoolExecutor { private ThreadPoolExecutor pool = null; /** * 线程池初始化方法 * * corePoolSize 核心线程池大小----1 * maximumPoolSize 最大线程池大小----3 * keepAliveTime 线程池中超过corePoolSize数目的空闲线程最大存活时间----30+单位TimeUnit * TimeUnit keepAliveTime时间单位----TimeUnit.MINUTES * workQueue 阻塞队列----new ArrayBlockingQueue&lt;Runnable&gt;(5)====5容量的阻塞队列 * threadFactory 新建线程工厂----new CustomThreadFactory()====定制的线程工厂 * rejectedExecutionHandler 当提交任务数超过maxmumPoolSize+workQueue之和时, * 即当提交第41个任务时(前面线程都没有执行完,此测试方法中用sleep(100)), * 任务会交给RejectedExecutionHandler来处理 */ public void init() { pool = new ThreadPoolExecutor( 1, 3, 30, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;Runnable&gt;(5), new CustomThreadFactory(), new CustomRejectedExecutionHandler()); } public void destory() { if(pool != null) { pool.shutdownNow(); } } public ExecutorService getCustomThreadPoolExecutor() { return this.pool; } private class CustomThreadFactory implements ThreadFactory { private AtomicInteger count = new AtomicInteger(0); @Override public Thread newThread(Runnable r) { Thread t = new Thread(r); String threadName = CustomThreadPoolExecutor.class.getSimpleName() + count.addAndGet(1); System.out.println(threadName); t.setName(threadName); return t; } } private class CustomRejectedExecutionHandler implements RejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { try { // 核心改造点，由blockingqueue的offer改成put阻塞方法 executor.getQueue().put(r); } catch (InterruptedException e) { e.printStackTrace(); } } } // 测试构造的线程池 public static void main(String[] args) { CustomThreadPoolExecutor exec = new CustomThreadPoolExecutor(); // 1.初始化 exec.init(); ExecutorService pool = exec.getCustomThreadPoolExecutor(); for(int i=1; i&lt;100; i++) { System.out.println(&quot;提交第&quot; + i + &quot;个任务!&quot;); pool.execute(new Runnable() { @Override public void run() { try { System.out.println(&quot;&gt;&gt;&gt;task is running=====&quot;); TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } }); } // 2.销毁----此处不能销毁,因为任务没有提交执行完,如果销毁线程池,任务也就无法执行了 // exec.destory(); try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } } } 解释：当提交任务被拒绝时，进入拒绝机制，我们实现拒绝方法，把任务重新用阻塞提交方法put提交，实现阻塞提交任务功能，防止队列过大，OOM，提交被拒绝方法在下面 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) // 进入拒绝机制， 我们把runnable任务拿出来，重新用阻塞操作put，来实现提交阻塞功能 reject(command); } 总结： 用ThreadPoolExecutor自定义线程池，看线程是的用途，如果任务量不大，可以用无界队列，如果任务量非常大，要用有界队列，防止OOM 如果任务量很大，还要求每个任务都处理成功，要对提交的任务进行阻塞提交，重写拒绝机制，改为阻塞提交。保证不抛弃一个任务 最大线程数一般设为2N+1最好，N是CPU核数 核心线程数，看应用，如果是任务，一天跑一次，设置为0，合适，因为跑完就停掉了，如果是常用线程池，看任务量，是保留一个核心还是几个核心线程数 如果要获取任务执行结果，用CompletionService，但是注意，获取任务的结果的要重新开一个线程获取，如果在主线程获取，就要等任务都提交后才获取，就会阻塞大量任务结果，队列过大OOM，所以最好异步开个线程获取结果]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
